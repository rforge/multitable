fake.community
Y <- fake.community[4:5,drop=FALSE]
Y
Y$body.size <- NULL
Y
Y <- fake.community[4:5,drop=FALSE]
Y
Y[[1,drop=FALSE]] <- NULL
Y
as.data.list(runif(10))
as.data.list(runif(10),drop=FALSE)
as.data.frame(runif(10))
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(a.dl,is_equivalent_to(a.df))#
})
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(a.dl,is_equivalent_to(a.df))#
})
?is_equivalent_to
is_equivalent_to
a <- b <- 1:3#
names(b) <- letters[1:3]#
expect_that(a, is_equivalent_to(b, label = b))#
expect_equivalent(a, b)
a <- runif(10)#
+ 	a.dl <- as.data.list(a)#
+ 	a.df <- as.data.frame(a)
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)
a
a.dl
a.df
attributes(a.dl)
attributes(a.df)
attributes(a.dl) <- NULL
attributes(a.df) <- NULL
a.dl
a.df
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)
unlist(a.dl)
unlist(a.df)
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- unlist(as.data.list(a))#
	a.df <- unlist(as.data.frame(a))#
	#
	expect_that(a.dl,is_equivalent_to(a.df))#
})
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
})
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
	expect_that(class(a.dl),equals("data.frame"))#
})
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
	expect_that(class(a.dl),equals("data.frame"))#
	expect_that(unlist(a.dl),is_equivalent_to(unlist(a.df)))#
})
data.list
multitable:::as.data.list.default
as.data.list
?as.data.list
multitable:::as.list.data.list
as.data.frame.data.list
multitable:::as.data.frame.data.list
multitable:::as.matrix.data.list
fake.community["abundance"]
library(multitable)
?Extract.data.list
data(fake.community)#
fake.community#
#
## array-like extraction#
fake.community[1:3,,]#
fake.community["arctic",c("2009","2008"),c(TRUE,TRUE,FALSE)]
## list-like extraction#
fake.community["abundance"]
fake.community["body.size"]
fake.community[c("abundance","body.size")]
fake.community[1:3]
fake.community[1:3,drop=FALSE]
fake.community$abundance  <- log(fake.community$abundance + 1)
fake.community[[6]] <- NULL#
fake.community$body.size <- fake.community$precipitation <- NULL#
fake.community
equals
testthat:::equals
#
fake.mold <- data.list.mold(fake.community)#
as.data.frame(fake.community)#
as.data.frame(fake.community,mold=fake.mold)
df <- as.data.frame(fake.community)
dfm <- as.data.frame(fake.community,mold=fake.mold)
testthat:::equals
all.equal(df,dfm)
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
	expect_that(class(a.dl),equals("data.frame"))#
	expect_that(unlist(a.dl),is_equivalent_to(unlist(a.df)))#
})#
#
test_that("as.data.frame molds",{#
	library(multitable)#
	data(fake.community)#
	fake.mold <- data.list.mold(fake.community)#
	#
	expect_that(as.data.frame(fake.community),#
		equals(as.data.frame(fake.community,mold=fake.mold)))#
	#
})
library(multitable)
?as.data.list
data(fake.community)
fake.mold <- data.list.mold(fake.community)#
fake.mold
as.data.frame(fake.community)
as.data.frame(fake.community,mold=fake.mold)
fake.community <- fake.community[4:6,drop=FALSE]#
as.data.frame(fake.community)
x <- runif(10)#
as.data.list(x)#
as.data.list(x,drop=FALSE)
as.list(fake.community)
as.list(fake.community,drop.attr=FALSE)
unclass(fake.community)
as.data.list
as.data.frame.data.list
multitable:::as.data.frame.data.list
as.data.frame(multitable)
as.data.frame(fake.community)
data(fake.community)
as.data.frame(fake.community)
as.data.frame(fake.community,row.names=1:(6*3*3))
as.data.frame(fake.community,optional=TRUE)
?as.data.frame
head(as.data.frame(fake.community,optional=TRUE))
?read.table
tempfile()
?tempfile
?write.table
?tempfile
?read.table
abundance.file <- tempfile()#
environment.file <- tempfile()#
trait.file <- tempfile()#
#
abundance <- data.frame(#
	sites=c(#
		"midlatitude","subtropical","tropical","equatorial","arctic","midlatitude","tropical","equatorial","subtropical"#
	),#
	species=c(rep("capybara",4),rep("moss",4),"vampire"),#
	abundance=c(4,10,8,7,5,6,9,3,1)#
)#
#
environment <- data.frame(#
	sites=c("arctic","subarctic","midlatitude","subtropical","tropical","equatorial"),#
	temperature=c(-30,0,10,20,50,30),#
	precipitation=c(20,40,20,100,150,200)#
)#
#
trait <- data.frame(#
	species=c("capybara","moss","vampire"),#
	body.size=c(140,5,190),#
	metabolic.rate=c(20,5,0)#
)#
#
write.table(abundance,abundance.file,sep=",")#
write.table(environment,environment.file,sep=",")#
write.table(trait,trait.file,sep=",")#
#
files <- c(abundance.file,environment.file,trait.file)#
dnames <- c("sites","species")#
read.multicsv(files,dnames,fill=c(0,NA,NA))
read.multitable
?dlcast
environment
dlcast(list(abundance,environment,trait),dnames=c("sites","species"))
dlcast(list(abundance,environment,trait),dnames=c("sites","species"),0)
dlcast
?as.data.frame
?lm
library(multitable)
?dimnames.data.list
dimnames.data.list
multitable:::dimnames.data.list
library(multitable)
?fake.community
data(fake.community)#
str(fake.community)#
summary(fake.community)
?print.data.list
library(vegan)
?rda
?summary.data.list
str(fake.community)
str(fake.community,give.attr = TRUE)
library(multitable)
?summary.data.list
data(fake.community)#
summary(fake.community)#
str(fake.community)
library(multitable)#
data(fake.community)
fake.community[["species",match.dnames="species"]] <- letters[1:3]
fake.community
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[3]
fake.community[["species"]] <- dimnames(fake.community)[3]
dimnames(fake.community)[3]
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]
fake.community[["species"]] <- dimnames(fake.community)[[3]]
fake.community[["species"]]
library(multitable)#
data(fake.community)#
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]
fake.community
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]
fake.community[["species"]] <- dimnames(fake.community)[[3]]
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
	expect_that(class(a.dl),equals("data.frame"))#
	expect_that(unlist(a.dl),is_equivalent_to(unlist(a.df)))#
})#
#
test_that("as.data.frame molds",{#
	library(multitable)#
	data(fake.community)#
	fake.mold <- data.list.mold(fake.community)#
	#
	expect_that(as.data.frame(fake.community),#
		equals(as.data.frame(fake.community,mold=fake.mold)))#
	#
})
library(multitable)#
data(fake.community)#
fake.community[["species"]] <- dimnames(fake.community)[[3]]
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]
fake.community
fake.community[["species"]] <- dimnames(fake.community)[[3]]
debug(multitable:::`[[<-.data.list`)
fake.community[["species"]] <- dimnames(fake.community)[[3]]
x
I(x)
xl
attributes(xl[[i]])
xl[[i]]
i
I(i)
value
xl
i
value
fake.community[["species"]] <- dimnames(fake.community)[[3]]
x
I(x)
nx
x
print(x)
?debug
xl
xl[[1]]
xl
Q
library(multitable)#
data(fake.community)#
fake.community[["temperature"]] <- fake.community[["temperature"]] + 1
Q
library(multitable)#
data(fake.community)#
fake.community[["temperature"]] <- fake.community[["temperature"]] + 1
Q
undebug(multitable:::`[[<-.data.list`)
library(multitable)#
data(fake.community)#
fake.community[["temperature"]] <- fake.community[["temperature"]] + 1
fake.community
library(multitable)#
data(fake.community)
fake.community
library(multitable)#
data(fake.community)
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]#
dm <- dimnames(fake.community)[[3]]#
fake.community[["species"]] <- dm
library(multitable)#
data(fake.community)
dm <- dimnames(fake.community)[[3]]#
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]#
fake.community[["species"]] <- dm
attr
library(multitable)#
data(fake.community)#
fake.community[["homeotherm"]] <- dimnames(fake.community)[[3]]
library(multitable)#
data(fake.community)#
fake.community[["homeotherm"]] <- letters[1:3]
library(multitable)#
data(fake.community)#
fake.community[["body.size"]] <- letters[1:3]
fake.community
library(multitable)#
data(fake.community)#
fake.community$body.size <- letters[1:3]
library(multitable)#
data(fake.community)
fake.community$homeotherm <- letters[1:3]
library(multitable)#
data(fake.community)
fake.community$homeotherm <- dimnames(fake.community)[[3]]
?attributes
attributes(fake.community[[1]])
attributes(fake.community[[2]])
attributes(fake.community[[3]])
attributes(fake.community[[4]])
attributes(fake.community[[5]])
attributes(fake.community[[6]])
attributes
attributes<-
`attributes<-`
attr(fake.community[[6]],"dim")
attr(fake.community[[6]],"subsetdim")
?attributes
datalistVARattributes <- function(dlvar){#
	list(#
		dim=attr(dlvar,"dim"),#
		dimnames=attr(dlvar,"dimnames"),#
		subsetdim=attr(dlvar,"subsetdim")#
	)#
}#
#
`datalistVARattributes<-` <- function(dlvar,value){#
	attr(dlvar,"dim") <- value$dim#
	attr(dlvar,"dimnames") <- value$dimnames#
	attr(dlvar,"subsetdim") <- value$subsetdim#
	return(dlvar)#
}
datalistVARattributes(fake.community[[1]])
datalistVARattributes(fake.community[[6]])
attributes(fake.community[[6]])
dlva <- datalistVARattributes(fake.community[[6]])
datalistVARattributes(fake.community[[6]]) <- dlva
dlva
fake.community[[6]]
attributes(fake.community[[6]])
library(testthat)#
#
context("data list subscripting")#
#
test_that("repdims are calculated correctly",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[-1,,]#
	#
	expect_that(attr(fake.community,"repdim"),equals(c(5,3,3)))#
})#
#
test_that("logical subscripting too long",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,rep(TRUE,4),],silent=TRUE)[1]#
	#
	expect_that(em,equals(#
		"Error in eval(expr, envir, enclos) : \n  (subscript) logical subscript too long\n"#
	))#
})#
#
test_that("long logical subscripting with 1D data lists",{#
	library(multitable)#
	data(fake.community)#
	fake.community <- fake.community[4:6,drop=FALSE]#
	fake.community <- fake.community[rep(TRUE,4),vextract=FALSE]#
	#
	expect_that(attr(fake.community,"repdim"),equals(4))#
	expect_that(is.na(fake.community[[1]][[4]]),is_true())#
	expect_that(is.na(fake.community[[2]][[4]]),is_true())#
	expect_that(is.na(fake.community[[3]][[4]]),is_true())#
})#
#
test_that("subscripting with empty character strings and completely empty subscripts",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[,],silent=TRUE)[1]#
	#
	expect_that(fake.community["","",""],is_identical_to(fake.community))#
	expect_that(fake.community[,"",""],is_identical_to(fake.community))#
	expect_that(fake.community["",,""],is_identical_to(fake.community))#
	expect_that(fake.community["","",],is_identical_to(fake.community))#
	expect_that(fake.community["",,],is_identical_to(fake.community))#
	expect_that(fake.community[,"",],is_identical_to(fake.community))#
	expect_that(fake.community[,,""],is_identical_to(fake.community))#
	expect_that(fake.community[,,],is_identical_to(fake.community))#
	expect_that(fake.community[],is_identical_to(fake.community))#
	expect_that(em,equals("Error in `[.data.list`(fake.community, , ) : \n  incorrect number of dimensions\n"))#
})#
#
test_that("NULL subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[NULL,,NULL],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, NULL, , NULL) : \n  NULL subscripting is not allowed in data lists\n"))#
})#
#
test_that("matrix subscripting",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[matrix(c(1,2,3,4,1,2,3,1,1,2,3,1),4,3)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, matrix(c(1, 2, 3, 4, 1, 2, 3, 1,  : \n  subscripting data lists with matrices is currently not allowed, but this may change in the future\n"))#
})#
#
test_that("too many variables extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6)],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in match.dnames[[which.max(sapply(match.dnames, length))]] : \n  attempt to select less than one element\n"))#
})#
#
test_that("too much extracted",{#
	library(multitable)#
	data(fake.community)#
	em <- try(fake.community[-(1:6),,],silent=TRUE)[1]#
	#
	expect_that(em,equals("Error in `[.data.list`(fake.community, -(1:6), , ) : \n  some replication dimensions have been reduced to zero length and this is not allowed\n"))#
})#
#
test_that("data list of a single vector becomes a data frame",{#
	library(multitable)#
	a <- runif(10)#
	a.dl <- as.data.list(a)#
	a.df <- as.data.frame(a)#
	#
	expect_that(class(a.dl),is_equivalent_to(class(a.df)))#
	expect_that(class(a.dl),equals("data.frame"))#
	expect_that(unlist(a.dl),is_equivalent_to(unlist(a.df)))#
})#
#
test_that("as.data.frame molds",{#
	library(multitable)#
	data(fake.community)#
	fake.mold <- data.list.mold(fake.community)#
	#
	expect_that(as.data.frame(fake.community),#
		equals(as.data.frame(fake.community,mold=fake.mold)))#
	#
})
library(multitable)#
data(fake.community)
fake.community$body.size <- letters[1:3]
library(multitable)#
data(fake.community)
fake.community$homeotherm <- letters[1:3]
debug(`[[<-.data.list`)
debug(multitable:::`[[<-.data.list`)
library(multitable)#
data(fake.community)
undebug(multitable:::`[[<-.data.list`)
library(multitable)#
data(fake.community)
fake.community[["body.size"]] <- letters[1:3]
library(multitable)#
data(fake.community)
fake.community[["homeotherm"]] <- letters[1:3]
fake.community
library(multitable)#
data(fake.community)
fake.community[["homeotherm"]] <- dimnames(fake.community)[[3]]
fake.community
library(multitable)#
data(fake.community)
dm <- dimnames(fake.community)[[3]]#
fake.community[["species",match.dnames="species"]] <- dimnames(fake.community)[[3]]#
fake.community[["species"]] <- dm
fake.community
fake.community[["species",match.dnames]] <- dm
fake.community
library(multitable)
?multitable
library(multitable)
?multitabe
?multitable
library(multitable)
?multitable
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/multitable.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
#
setwd("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/")#
Sweave("/users/stevenwalker/documents/multitable/multitable/pkg/multitable/inst/doc/readingmultipletables.Rnw")
